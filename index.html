<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>테트리스 블록 대포 게임</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #2c3e50;
            font-family: Arial, sans-serif;
        }
        #game-container {
            text-align: center;
        }
        #instructions {
            color: white;
            margin-bottom: 10px;
            font-size: 16px;
        }
        #game {
            border: 2px solid #fff;
            background-color: #87CEEB;
            cursor: crosshair;
        }
        #debug {
            color: white;
            margin-top: 10px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="instructions">마우스 방향으로 테트리스 블록 발사!</div>
        <div id="game"></div>
        <div id="debug">디버그 정보가 여기에 표시됩니다</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.70.0/phaser.min.js"></script>
    <script>
        const debugElement = document.getElementById('debug');
        
        function log(message) {
            console.log(message);
            debugElement.textContent = message;
        }

        class GameScene extends Phaser.Scene {
            constructor() {
                super({ key: 'GameScene' });
                this.cannon = null;
                this.blocks = [];
                this.canShoot = true;
                this.blockCount = 0;
                this.gameOver = false;
                this.blockSize = 24; // 블록 크기
            }

            create() {
                log("게임 scene 생성 중...");
                
                // Matter.js 설정 조정
                this.matter.world.engine.positionIterations = 6;
                this.matter.world.engine.velocityIterations = 4;
                
                // 배경색 설정
                this.cameras.main.setBackgroundColor('#87CEEB');
                
                // 바닥 생성 (구멍이 있는 바닥)
                const groundGraphics = this.add.graphics();
                groundGraphics.fillStyle(0x8B4513);
                
                // 왼쪽 바닥
                groundGraphics.fillRect(0, 560, 150, 40);
                // 가운데 바닥 
                groundGraphics.fillRect(250, 560, 300, 40);
                // 오른쪽 바닥
                groundGraphics.fillRect(650, 560, 150, 40);
                
                // 물리 바닥들 (구멍 제외)
                this.matter.add.rectangle(75, 580, 150, 40, { 
                    isStatic: true,
                    label: 'ground',
                    friction: 0.8,
                    restitution: 0.2 // 약간의 탄성
                });
                this.matter.add.rectangle(400, 580, 300, 40, { 
                    isStatic: true,
                    label: 'ground',
                    friction: 0.8,
                    restitution: 0.2
                });
                this.matter.add.rectangle(725, 580, 150, 40, { 
                    isStatic: true,
                    label: 'ground',
                    friction: 0.8,
                    restitution: 0.2
                });

                // 좌우 벽 (시각적)
                const wallGraphics = this.add.graphics();
                wallGraphics.fillStyle(0x8B4513);
                wallGraphics.fillRect(0, 0, 40, 600);
                wallGraphics.fillRect(760, 0, 40, 600);
                
                // 물리 벽 - 높은 탄성으로 당구공처럼 튕기게
                this.matter.add.rectangle(20, 300, 40, 600, { 
                    isStatic: true,
                    label: 'leftWall',
                    restitution: 0.9, // 높은 탄성
                    friction: 0.1     // 낮은 마찰
                });
                this.matter.add.rectangle(780, 300, 40, 600, { 
                    isStatic: true,
                    label: 'rightWall',
                    restitution: 0.9, // 높은 탄성
                    friction: 0.1     // 낮은 마찰
                });

                // 대포 생성
                this.createCannon();

                // 클릭 이벤트
                this.input.on('pointerdown', (pointer) => {
                    this.shootBlock(pointer);
                }, this);
                
                log("게임 초기화 완료! 클릭해보세요.");
            }

            createCannon() {
                // 뿌요뿌요 스타일 위쪽 대포 그래픽 생성
                this.cannon = this.add.graphics();
                
                // 대포 받침대 (넓은 베이스) - 맨 위쪽
                this.cannon.fillStyle(0x444444);
                this.cannon.fillRoundedRect(360, 20, 80, 40, 8);
                
                // 대포 본체 (짧고 통통한 원통)
                this.cannon.fillStyle(0x333333);
                this.cannon.fillRoundedRect(375, 50, 50, 50, 10);
                
                // 대포 포신 (아래쪽을 향한 짧은 총구)
                this.cannon.fillStyle(0x222222);
                this.cannon.fillRoundedRect(390, 95, 20, 25, 5);
                
                // 대포 장식 고리들
                this.cannon.lineStyle(3, 0x666666);
                this.cannon.strokeRect(375, 55, 50, 8);
                this.cannon.strokeRect(375, 70, 50, 8);
                this.cannon.strokeRect(375, 85, 50, 8);
                
                // 발사구 하이라이트
                this.cannon.fillStyle(0x555555);
                this.cannon.fillCircle(400, 107, 6);
            }

            // 테트리스 블록 형태 정의
            getBlockShapes() {
                return {
                    // I 블록 (길쭉한 막대)
                    I: {
                        shape: [[0, -1.5], [0, -0.5], [0, 0.5], [0, 1.5]],
                        vertices: [
                            { x: -12, y: -48 },
                            { x: 12, y: -48 },
                            { x: 12, y: 48 },
                            { x: -12, y: 48 }
                        ],
                        color: 0x00ffff
                    },
                    // O 블록 (정사각형)
                    O: {
                        shape: [[-0.5, -0.5], [0.5, -0.5], [-0.5, 0.5], [0.5, 0.5]],
                        vertices: [
                            { x: -24, y: -24 },
                            { x: 24, y: -24 },
                            { x: 24, y: 24 },
                            { x: -24, y: 24 }
                        ],
                        color: 0xffff00
                    },
                    // T 블록 (T자 모양)
                    T: {
                        shape: [[0, -1], [-1, 0], [0, 0], [1, 0]],
                        vertices: [
                            { x: -36, y: -12 },
                            { x: -12, y: -12 },
                            { x: -12, y: -36 },
                            { x: 12, y: -36 },
                            { x: 12, y: -12 },
                            { x: 36, y: -12 },
                            { x: 36, y: 12 },
                            { x: -36, y: 12 }
                        ],
                        color: 0xff00ff
                    },
                    // S 블록 (지그재그)
                    S: {
                        shape: [[-1, 0.5], [0, 0.5], [0, -0.5], [1, -0.5]],
                        vertices: [
                            { x: -36, y: 0 },
                            { x: -12, y: 0 },
                            { x: -12, y: -24 },
                            { x: 36, y: -24 },
                            { x: 36, y: 0 },
                            { x: 12, y: 0 },
                            { x: 12, y: 24 },
                            { x: -36, y: 24 }
                        ],
                        color: 0x00ff00
                    },
                    // Z 블록 (역 지그재그)
                    Z: {
                        shape: [[-1, -0.5], [0, -0.5], [0, 0.5], [1, 0.5]],
                        vertices: [
                            { x: -36, y: -24 },
                            { x: 12, y: -24 },
                            { x: 12, y: 0 },
                            { x: 36, y: 0 },
                            { x: 36, y: 24 },
                            { x: -12, y: 24 },
                            { x: -12, y: 0 },
                            { x: -36, y: 0 }
                        ],
                        color: 0xff0000
                    },
                    // J 블록 (L자 모양)
                    J: {
                        shape: [[0, -1], [0, 0], [0, 1], [-1, 1]],
                        vertices: [
                            { x: -12, y: -36 },
                            { x: 12, y: -36 },
                            { x: 12, y: 36 },
                            { x: -36, y: 36 },
                            { x: -36, y: 12 },
                            { x: -12, y: 12 }
                        ],
                        color: 0x0000ff
                    },
                    // L 블록 (역 L자 모양)
                    L: {
                        shape: [[0, -1], [0, 0], [0, 1], [1, 1]],
                        vertices: [
                            { x: -12, y: -36 },
                            { x: 12, y: -36 },
                            { x: 12, y: 12 },
                            { x: 36, y: 12 },
                            { x: 36, y: 36 },
                            { x: -12, y: 36 }
                        ],
                        color: 0xff8000
                    }
                };
            }

            createTetrisBlock(startX, startY, blockType) {
                const shapes = this.getBlockShapes();
                const shape = shapes[blockType];
                
                // 시각적 블록들을 담을 컨테이너
                const visualBlocks = [];
                
                // 각 작은 블록 생성 (시각적 표현용)
                shape.shape.forEach((pos) => {
                    const x = startX + pos[0] * this.blockSize;
                    const y = startY + pos[1] * this.blockSize;
                    
                    // 시각적 블록
                    const visualBlock = this.add.rectangle(x, y, this.blockSize - 1, this.blockSize - 1, shape.color);
                    visualBlock.setStrokeStyle(1, 0x000000);
                    visualBlocks.push(visualBlock);
                });
                
                // 단일 물리 객체로 생성
                const physicsBlock = this.matter.bodies.fromVertices(startX, startY, shape.vertices, {
                    restitution: 0.6,      // 벽에 튕기는 탄성
                    friction: 0.3,         // 적당한 마찰
                    frictionStatic: 0.6,   // 정지 마찰
                    frictionAir: 0.01,     // 공기 저항
                    density: 0.001,        // 밀도
                    label: 'tetrisBlock'
                });
                
                // Matter world에 추가
                this.matter.world.add(physicsBlock);
                
                return { physicsBlock, visualBlocks, shape: shape.shape };
            }

            shootBlock(pointer) {
                if (!this.canShoot || this.gameOver) {
                    if (this.gameOver) {
                        log("게임 오버! 새로고침하여 다시 시작하세요.");
                    } else {
                        log("쿨타임 중... 잠시 기다려주세요");
                    }
                    return;
                }
                
                this.blockCount++;
                
                // 랜덤 블록 타입 선택
                const blockTypes = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
                const randomType = blockTypes[Math.floor(Math.random() * blockTypes.length)];
                
                log(`${randomType} 블록 ${this.blockCount}번 발사!`);
                
                // 블록 생성 위치 (대포 포신 끝)
                const startX = 400;
                const startY = 125;
                
                // 테트리스 블록 생성
                const block = this.createTetrisBlock(startX, startY, randomType);
                
                // 마우스 방향으로 발사 각도 계산
                const angle = Math.atan2(pointer.y - startY, pointer.x - startX);
                const speed = 6; // 발사 속도
                
                const velocityX = Math.cos(angle) * speed;
                const velocityY = Math.sin(angle) * speed;
                
                this.matter.body.setVelocity(block.physicsBlock, { x: velocityX, y: velocityY });
                
                // 블록 회전
                this.matter.body.setAngularVelocity(block.physicsBlock, (Math.random() - 0.5) * 0.1);
                
                this.blocks.push(block);

                // 대포 발사 효과 (마우스 방향으로 회전)
                const cannonAngle = angle + Math.PI / 2; // 90도 조정
                this.cannon.setRotation(cannonAngle * 0.1); // 살짝만 회전
                
                this.tweens.add({
                    targets: this.cannon,
                    scaleY: 0.95,
                    scaleX: 1.05,
                    rotation: 0,
                    duration: 100,
                    yoyo: true,
                    ease: 'Power2'
                });

                // 발사 사운드 효과 (시각적)
                const flash = this.add.circle(400, 107, 20, 0xffff00, 0.8);
                this.tweens.add({
                    targets: flash,
                    alpha: 0,
                    scale: 2,
                    duration: 200,
                    onComplete: () => flash.destroy()
                });

                // 쿨타임 설정
                this.canShoot = false;
                this.time.delayedCall(500, () => {
                    this.canShoot = true;
                    log(`다음 블록 준비 완료! (총 ${this.blockCount}개 발사됨)`);
                });
            }

            update() {
                // 시각적 블록과 물리 블록 위치 동기화
                this.blocks.forEach(block => {
                    if (block.physicsBlock && block.visualBlocks) {
                        const centerX = block.physicsBlock.position.x;
                        const centerY = block.physicsBlock.position.y;
                        const angle = block.physicsBlock.angle;
                        
                        // 속도가 충분히 느려지면 정지
                        const velocity = block.physicsBlock.velocity;
                        const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
                        const angularSpeed = Math.abs(block.physicsBlock.angularVelocity);
                        
                        // 바닥에 있고 속도가 느리면 정지
                        if (centerY > 520 && speed < 0.5 && angularSpeed < 0.01) {
                            this.matter.body.setVelocity(block.physicsBlock, { x: 0, y: 0 });
                            this.matter.body.setAngularVelocity(block.physicsBlock, 0);
                            // 정지 상태로 설정
                            this.matter.body.setStatic(block.physicsBlock, true);
                        }
                        
                        // 각 시각적 블록 업데이트
                        block.visualBlocks.forEach((visualBlock, index) => {
                            const relPos = block.shape[index];
                            
                            // 회전 변환
                            const cos = Math.cos(angle);
                            const sin = Math.sin(angle);
                            const rotX = relPos[0] * cos - relPos[1] * sin;
                            const rotY = relPos[0] * sin + relPos[1] * cos;
                            
                            visualBlock.setPosition(
                                centerX + rotX * this.blockSize,
                                centerY + rotY * this.blockSize
                            );
                            visualBlock.setRotation(angle);
                        });
                        
                        // 게임오버 구역 체크
                        if (centerY > 540) {
                            if ((centerX > 150 && centerX < 250) || (centerX > 550 && centerX < 650)) {
                                this.triggerGameOver();
                                return;
                            }
                        }
                    }
                });
                
                // 화면 밖으로 나간 블록들 정리
                this.blocks = this.blocks.filter(block => {
                    const pos = block.physicsBlock.position;
                    if (pos.y > 650 || pos.x < -50 || pos.x > 850) {
                        // 물리 블록 제거
                        this.matter.world.remove(block.physicsBlock);
                        // 시각적 블록들 제거
                        block.visualBlocks.forEach(vb => vb.destroy());
                        return false;
                    }
                    return true;
                });
            }
            
            triggerGameOver() {
                this.gameOver = true;
                log("게임 오버! 블록이 구멍에 떨어졌습니다!");
                
                // 게임오버 효과
                this.cameras.main.shake(300, 0.02);
                
                // 게임오버 텍스트 표시
                this.add.text(400, 300, 'GAME OVER!', {
                    fontSize: '48px',
                    fill: '#ff0000',
                    fontWeight: 'bold',
                    stroke: '#ffffff',
                    strokeThickness: 4
                }).setOrigin(0.5);
                
                this.add.text(400, 350, '새로고침하여 다시 시작', {
                    fontSize: '24px',
                    fill: '#ffffff',
                    fontWeight: 'bold',
                    stroke: '#000000',
                    strokeThickness: 2
                }).setOrigin(0.5);
            }
        }

        // 게임 설정
        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            parent: 'game',
            backgroundColor: '#87CEEB',
            physics: {
                default: 'matter',
                matter: {
                    gravity: { y: 0.6 },
                    debug: false,
                    enableSleeping: true
                }
            },
            scene: GameScene
        };

        // 게임 시작
        try {
            const game = new Phaser.Game(config);
            log("게임 로딩 완료!");
        } catch (error) {
            log("게임 시작 에러: " + error.message);
            console.error(error);
        }
    </script>
</body>
</html>
